<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 让我们从一个函数里创建一个对象o，它自身拥有属性a和b的：
        let f = function() {
                this.a = 1;
                this.b = 2;
            }
            /* 这么写也一样
            function f() {
              this.a = 1;
              this.b = 2;
            }
            */
        let o = new f(); // {a: 1, b: 2}

        // 在f函数的原型上定义属性
        f.prototype.b = 3;
        f.prototype.c = 4;

        // 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链
        // o.[[Prototype]] 有属性 b 和 c
        //  (其实就是 o.__proto__ 或者 o.constructor.prototype)
        // o.[[Prototype]].[[Prototype]] 是 Object.prototype.
        // 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null
        // 这就是原型链的末尾，即 null，
        // 根据定义，null 就是没有 [[Prototype]]。

        // 综上，整个原型链如下: 

        // {a:1, b:2} ---> {b:3, c:4} ---> Object.prototype---> null

        console.log(o.a); // 1
        // a是o的自身属性吗？是的，该属性的值为 1

        console.log(o.b); // 2
        // b是o的自身属性吗？是的，该属性的值为 2
        // 原型上也有一个'b'属性，但是它不会被访问到。
        // 这种情况被称为"属性遮蔽 (property shadowing)"

        console.log(o.c); // 4
        // c是o的自身属性吗？不是，那看看它的原型上有没有
        // c是o.[[Prototype]]的属性吗？是的，该属性的值为 4

        console.log(o.d); // undefined
        // d 是 o 的自身属性吗？不是，那看看它的原型上有没有
        // d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有
        // o.[[Prototype]].[[Prototype]] 为 null，停止搜索
        // 找不到 d 属性，返回 undefined

        var n = {
            a: 2,
            m: function() {
                return this.a + 1;
            }
        };

        console.log(n.m()); // 3
        // 当调用 o.m 时，'this' 指向了 o.

        var p = Object.create(n);
        // p是一个继承自 o 的对象

        p.a = 4; // 创建 p 的自身属性 'a'
        console.log(p.m()); // 5
        // 调用 p.m 时，'this' 指向了 p
        // 又因为 p 继承了 o 的 m 函数
        // 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a'
    </script>
</body>

</html>